[
  {
    "id": "gr-networking-terraform-links",
    "topic": "networking",
    "cloud": null,
    "iac": "terraform",
    "check_type": "links/dr",
    "scope": "senior/terraform",
    "requires_tools": [
      "python3"
    ],
    "signals": [
      "alias_missing",
      "secondary_usage_missing",
      "reverse_link_missing",
      "route_assoc_missing",
      "private_dns_link_missing"
    ],
    "command": "python - <<'PY'\nimport os, re, sys, json\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: required links missing'\nPASS='guardrail met'\nroot_arg=os.environ.get('IAC_ROOT','senior/terraform')\nROOT=Path(root_arg)\nif not ROOT.exists():\n    print(FAIL)\n    print('issues: iac_path_missing=1')\n    sys.exit(1)\n\nalias_missing=0\nsecondary_usage_missing=0\nreverse_link_missing=0\nroute_assoc_missing=0\nprivate_dns_link_missing=0\n\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\ntext='\\n'.join(texts)\njs='\\n'.join(json.dumps(d, default=str) for d in docs)\nhay=text + '\\n' + js\n\n# provider alias and usage\nif re.search(r'provider\\s+\"azurerm\"[^}]*alias\\s*=\\s*\"secondary\"', hay, re.S|re.I) is None:\n    alias_missing=1\nif re.search(r'providers\\s*=\\s*\\{[^}]*azurerm\\s*=\\s*azurerm\\.secondary', hay, re.S|re.I) is None and re.search(r'provider\\s*=\\s*azurerm\\.secondary', hay, re.S|re.I) is None:\n    secondary_usage_missing=1\n\n# Count resource blocks (offline-safe; modules/for_each are not expanded)\ndef _count_blocks(rtype):\n    return len(re.findall(r'resource\\s+\"{}\"\\s+\"'.format(re.escape(rtype)), text, re.I))\n\ndef _resource_has_for_each(rtype):\n    pat = r'resource\\s+\"{}\"\\s+\"[^\\\"]+\"\\s*\\{{[^}}]*\\bfor_each\\b'.format(re.escape(rtype))\n    return re.search(pat, text, re.I | re.S) is not None\n\ndef _module_has_for_each(token):\n    pat = r'module\\s+\"[^\\\"]+\"\\s*\\{{[^}}]*source\\s*=\\s*\"[^\\\"]*{}[^\\\"]*\"[^}}]*\\bfor_each\\b'.format(re.escape(token))\n    return re.search(pat, text, re.I | re.S) is not None\n\npeering_blocks = _count_blocks('azurerm_virtual_network_peering')\nroute_assoc_blocks = _count_blocks('azurerm_subnet_route_table_association')\ndns_link_blocks = _count_blocks('azurerm_private_dns_zone_virtual_network_link')\n\npeering_for_each = _resource_has_for_each('azurerm_virtual_network_peering') or _module_has_for_each('modules/peering')\nroute_assoc_for_each = _resource_has_for_each('azurerm_subnet_route_table_association')\ndns_link_for_each = _resource_has_for_each('azurerm_private_dns_zone_virtual_network_link')\n\n# Reverse link heuristic (both directions referenced)\nprimary_to_secondary = re.search(r'remote_virtual_network_id\\s*=.*(secondary|hub_secondary|sec)', hay, re.S|re.I)\nsecondary_to_primary = re.search(r'remote_virtual_network_id\\s*=.*(primary|hub_primary|pri)', hay, re.S|re.I)\nif not (primary_to_secondary and secondary_to_primary):\n    reverse_link_missing = 1\n\n# Minimum block counts + for_each scaling\nif peering_blocks < 1 or not peering_for_each:\n    reverse_link_missing = 1\nif route_assoc_blocks < 2 or not route_assoc_for_each:\n    route_assoc_missing = 1\nif dns_link_blocks < 2 or not dns_link_for_each:\n    private_dns_link_missing = 1\n\nif any([alias_missing, secondary_usage_missing, reverse_link_missing, route_assoc_missing, private_dns_link_missing]):\n    print(FAIL)\n    print(\n        \"issues: alias_missing={}, secondary_usage_missing={}, reverse_link_missing={}, route_assoc_missing={}, private_dns_link_missing={}, peering_blocks={}, route_assoc_blocks={}, dns_link_blocks={}, peering_for_each={}, route_assoc_for_each={}, dns_link_for_each={}\"\n        .format(\n            alias_missing,\n            secondary_usage_missing,\n            reverse_link_missing,\n            route_assoc_missing,\n            private_dns_link_missing,\n            peering_blocks,\n            route_assoc_blocks,\n            dns_link_blocks,\n            int(bool(peering_for_each)),\n            int(bool(route_assoc_for_each)),\n            int(bool(dns_link_for_each)),\n        )\n    )\n    sys.exit(1)\n\nprint(PASS)\nPY\n",
    "fail_message": "guardrail unmet: required links missing",
    "source": "opa-contrib + checkov patterns",
    "license": "Apache-2.0",
    "notes": "Offline-safe heuristic: block-aware counts with for_each scaling, requires alias + secondary usage, reverse links, route associations, and private DNS VNet links; aggregated signals only; scoped to senior/terraform. Requires python-hcl2."
  },
  {
    "id": "gr-security-terraform-lpv",
    "topic": "security",
    "cloud": null,
    "iac": "terraform",
    "check_type": "policy_lpv",
    "scope": "senior/terraform",
    "requires_tools": [
      "python3"
    ],
    "signals": [
      "high_risk_verbs",
      "broad_scopes",
      "missing_not_actions",
      "overbroad_builtins",
      "secondary_missing"
    ],
    "command": "python - <<'PY'\nimport os, re, sys, json\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: least-privilege policy violation'\nPASS='guardrail met'\nroot_arg=os.environ.get('IAC_ROOT','senior/terraform')\nROOT=Path(root_arg)\nif not ROOT.exists():\n    print(FAIL)\n    print('issues: iac_path_missing=1')\n    sys.exit(1)\n\nhigh_risk_verbs=broad_scopes=missing_not_actions=overbroad_builtins=secondary_missing=0\nHIGH_RISK=re.compile(r\"Microsoft\\\\.(Authorization/.*/write|KeyVault/.*/delete)\", re.I)\nASSIGNABLE=re.compile(r\"assignable_scopes\\s*=\\s*\\\\[(.*?)\\\\]\", re.S|re.I)\nPERMS=re.compile(r\"permissions\\s*{(.*?)}\", re.S|re.I)\nACTIONS=re.compile(r\"actions\\s*=\\s*\\\\[(.*?)\\\\]\", re.S|re.I)\nNOT_ACTIONS=re.compile(r\"not_actions\\s*=\\s*\\\\[(.*?)\\\\]\", re.S|re.I)\nOWNER_CONTRIB=re.compile(r\"role_definition_name\\s*=\\s*\\\"(?:Owner|Contributor)\\\"\", re.I)\nSECONDARY=re.compile(r\"\\balias\\s*=\\s*\\\"secondary\\\"|secondary_location|secondary_region|dr_\", re.I)\nsecondary_seen=False\n\ntexts=[]\ndocs=[]\nfor tf in ROOT.rglob('*.tf'):\n    try:\n        text=tf.read_text(errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\ntext='\\n'.join(texts)\njs='\\n'.join(json.dumps(d, default=str) for d in docs)\nhay=text + '\\n' + js\n\nif SECONDARY.search(hay):\n    secondary_seen=True\nfor perm in PERMS.finditer(hay):\n    block=perm.group(1)\n    actions=ACTIONS.search(block)\n    if actions and HIGH_RISK.search(actions.group(1)):\n        high_risk_verbs+=1\n    if NOT_ACTIONS.search(block) is None:\n        missing_not_actions+=1\nfor scopes in ASSIGNABLE.finditer(hay):\n    if re.search(r\"/subscriptions/|/providers/microsoft\\.authorization\", scopes.group(1), re.I):\n        broad_scopes+=1\nif OWNER_CONTRIB.search(hay):\n    overbroad_builtins+=1\n\nif not secondary_seen:\n    secondary_missing=1\n\nif any([high_risk_verbs,broad_scopes,missing_not_actions,overbroad_builtins,secondary_missing]):\n    print(FAIL)\n    print(\n        \"issues: \"\n        f\"high_risk_verbs={high_risk_verbs}, \"\n        f\"broad_scopes={broad_scopes}, \"\n        f\"missing_not_actions={missing_not_actions}, \"\n        f\"overbroad_builtins={overbroad_builtins}, \"\n        f\"secondary_missing={secondary_missing}\"\n    )\n    sys.exit(1)\nprint(PASS)\nPY\n",
    "fail_message": "guardrail unmet: least-privilege policy violation",
    "source": "checkov rule patterns + azure role_definition",
    "license": "Apache-2.0",
    "notes": "Offline-safe LPV heuristic: high-risk verbs, broad scopes, missing not_actions, over-broad built-ins; aggregated counts only (no file paths). Requires python-hcl2."
  },
  {
    "id": "gr-cost-terraform-tags",
    "topic": "cost",
    "cloud": null,
    "iac": "terraform",
    "check_type": "tags",
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: standard tags missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\nif re.search(r'\\bOwner\\b', hay, re.I) and re.search(r'\\bCostCenter\\b', hay, re.I):\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: standard tags missing",
    "source": "internal baseline",
    "license": null,
    "notes": "Offline-safe heuristic for chargeback tags in config. Requires python-hcl2."
  },
  {
    "id": "gr-dr-terraform-secondary",
    "topic": "dr",
    "cloud": null,
    "iac": "terraform",
    "check_type": "dr_secondary",
    "scope": "senior/terraform",
    "requires_tools": [
      "python3"
    ],
    "signals": [
      "alias_missing",
      "secondary_usage_missing",
      "reverse_link_missing",
      "secondary_origin_disabled"
    ],
    "command": "python - <<'PY'\nimport os, re, sys, json\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: DR secondary missing'\nPASS='guardrail met'\nroot_arg=os.environ.get('IAC_ROOT','senior/terraform')\nROOT=Path(root_arg)\nif not ROOT.exists():\n    print(FAIL)\n    print('issues: iac_path_missing=1')\n    sys.exit(1)\n\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\ntext='\\n'.join(texts)\njs='\\n'.join(json.dumps(d, default=str) for d in docs)\nhay=text + '\\n' + js\n\nalias_missing=0\nsecondary_usage_missing=0\nreverse_link_missing=0\nsecondary_origin_disabled=0\n\n# alias present\nif re.search(r'provider\\s+\"azurerm\"[^}]*alias\\s*=\\s*\"secondary\"', hay, re.S|re.I) is None:\n    alias_missing=1\n\n# secondary usage (modules/resources bound to azurerm.secondary)\nif re.search(r'providers\\s*=\\s*\\{[^}]*azurerm\\s*=\\s*azurerm\\.secondary', hay, re.S|re.I) is None and re.search(r'provider\\s*=\\s*azurerm\\.secondary', hay, re.S|re.I) is None:\n    secondary_usage_missing=1\n\n# reverse peering/route heuristic (look for peering/route that references both primary and secondary)\npeer_pattern=r'virtual_network_peering|vpn|gateway|route_table'\nif re.search(peer_pattern, hay, re.I):\n    # require at least one reference to secondary and one to primary in peering-like blocks\n    if not re.search(r'remote_virtual_network_id\\s*=.*secondary', hay, re.S|re.I) or not re.search(r'remote_virtual_network_id\\s*=.*primary', hay, re.S|re.I):\n        reverse_link_missing=1\nelse:\n    reverse_link_missing=1\n\n# origin/entry health: require secondary origin enabled\nfor m in re.finditer(r'resource\\s+\"azurerm_cdn_frontdoor_origin\"\\s+\"[^\\\"]+\"\\s*\\{(.*?)\\}', hay, re.S|re.I):\n    block=m.group(1)\n    name=re.search(r'name\\s*=\\s*\"([^\"]+)\"', block)\n    if name and 'secondary' in name.group(1).lower():\n        en=re.search(r'enabled\\s*=\\s*(true|false)', block, re.I)\n        if en and en.group(1).lower()=='false':\n            secondary_origin_disabled=1\n            break\n\nif any([alias_missing, secondary_usage_missing, reverse_link_missing, secondary_origin_disabled]):\n    print(FAIL)\n    print(\n        'issues: '\n        f'alias_missing={alias_missing}, '\n        f'secondary_usage_missing={secondary_usage_missing}, '\n        f'reverse_link_missing={reverse_link_missing}, '\n        f'secondary_origin_disabled={secondary_origin_disabled}'\n    )\n    sys.exit(1)\n\nprint(PASS)\nPY\n",
    "fail_message": "guardrail unmet: DR secondary missing",
    "source": "topic fingerprint baseline",
    "license": null,
    "notes": "Offline-safe DR heuristic: requires provider alias + secondary usage, reverse link/route presence, and secondary origin enabled; aggregated counts only, scoped to senior/terraform. Requires python-hcl2."
  },
  {
    "id": "gr-observability-terraform-telemetry",
    "topic": "observability",
    "cloud": null,
    "iac": "terraform",
    "check_type": "telemetry",
    "command": "python - <<'PY'\nimport os, json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: telemetry missing'\nPASS='guardrail met'\nroot_arg=os.environ.get('IAC_ROOT','senior/terraform')\nROOT=Path(root_arg)\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.glob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern=r'resource\\s+\\\"(azurerm_monitor_diagnostic_setting|azurerm_log_analytics_workspace|aws_cloudwatch_log_group|aws_cloudwatch_metric_alarm|google_logging_project_sink|google_monitoring_alert_policy)\\\"'\nif re.search(pattern, hay, re.I):\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: telemetry missing",
    "source": "checkov patterns",
    "license": "Apache-2.0",
    "notes": "Offline-safe heuristic requiring at least one telemetry resource. Requires python-hcl2."
  },
  {
    "id": "gr-ci-cd-terraform-secret-scope",
    "topic": "ci_cd",
    "cloud": null,
    "iac": "terraform",
    "check_type": "secret_scope",
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: secret scope missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\nif re.search(r'\\bsensitive\\s*=\\s*true\\b', hay, re.I):\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: secret scope missing",
    "source": "policy-as-code patterns",
    "license": null,
    "notes": "Offline-safe heuristic: expects at least one sensitive variable/output to exist. Requires python-hcl2."
  },
  {
    "id": "gr-networking-bicep-links",
    "topic": "networking",
    "cloud": "azure",
    "iac": "bicep",
    "check_type": "links/dr",
    "command": "az bicep build --file main.bicep --stdout | jq -e '..|objects|select(has(\"type\"))|.type|ascii_downcase|test(\"virtualnetworkpeerings|connections|routes\")' >/dev/null || (echo \"guardrail unmet: required links missing\" && exit 1)",
    "fail_message": "guardrail unmet: required links missing",
    "source": "opa-contrib patterns",
    "license": "Apache-2.0",
    "notes": "Neutral link/peering/route presence check."
  },
  {
    "id": "gr-security-bicep-lpv",
    "topic": "security",
    "cloud": "azure",
    "iac": "bicep",
    "check_type": "policy_lpv",
    "command": "az bicep build --file main.bicep --stdout | python - <<'PY'\nimport sys, json, re\nFAIL='guardrail unmet: least-privilege policy violation'\nPASS='guardrail met'\ndata=json.load(sys.stdin)\njs=json.dumps(data)\ncount=0\nif re.search(r'\\\\b(Owner|Contributor)\\\\b', js, re.I):\n    count+=1\nif re.search(r'Microsoft\\\\.(Authorization/.*/write|KeyVault/.*/delete)', js, re.I):\n    count+=1\nif count>0:\n    print(FAIL)\n    print(\"issues: high_risk_or_overbroad={}\".format(count))\n    sys.exit(1)\nprint(PASS)\nPY\n",
    "fail_message": "guardrail unmet: least-privilege policy violation",
    "source": "policy-as-code patterns",
    "license": null,
    "notes": "LPV heuristic for Bicep: flags Owner/Contributor or high-risk verbs; aggregated counts only."
  },
  {
    "id": "gr-cost-bicep-tags",
    "topic": "cost",
    "cloud": "azure",
    "iac": "bicep",
    "check_type": "tags",
    "command": "az bicep build --file main.bicep --stdout | jq -e '..|objects|select(has(\"tags\"))|.tags|keys|map(ascii_downcase) | index(\"owner\") and index(\"costcenter\")' >/dev/null || (echo \"guardrail unmet: standard tags missing\" && exit 1)",
    "fail_message": "guardrail unmet: standard tags missing",
    "source": "internal baseline",
    "license": null,
    "notes": "Chargeback tags check."
  },
  {
    "id": "gr-dr-bicep-secondary",
    "topic": "dr",
    "cloud": "azure",
    "iac": "bicep",
    "check_type": "dr_secondary",
    "command": "az bicep build --file main.bicep --stdout | jq -e '..|objects|select(has(\"location\"))|.location|ascii_downcase|test(\"(secondary|dr)\")' >/dev/null || (echo \"guardrail unmet: DR secondary missing\" && exit 1)",
    "fail_message": "guardrail unmet: DR secondary missing",
    "source": "topic fingerprint baseline",
    "license": null,
    "notes": "Requires secondary region artifacts."
  },
  {
    "id": "gr-observability-bicep-telemetry",
    "topic": "observability",
    "cloud": "azure",
    "iac": "bicep",
    "check_type": "telemetry",
    "command": "az bicep build --file main.bicep --stdout | jq -e '..|objects|select(has(\"type\"))|.type|ascii_downcase|test(\"diagnosticsettings|monitor\");' >/dev/null || (echo \"guardrail unmet: telemetry missing\" && exit 1)",
    "fail_message": "guardrail unmet: telemetry missing",
    "source": "checkov patterns",
    "license": "Apache-2.0",
    "notes": "Requires diagnostic/monitor resources."
  },
  {
    "id": "gr-ci-cd-bicep-secret-scope",
    "topic": "ci_cd",
    "cloud": "azure",
    "iac": "bicep",
    "check_type": "secret_scope",
    "command": "az bicep build --file main.bicep --stdout | jq -e '..|objects|select(has(\"properties\"))|.properties|tostring|test(\"secret|keyvault\")' >/dev/null || (echo \"guardrail unmet: secret scope missing\" && exit 1)",
    "fail_message": "guardrail unmet: secret scope missing",
    "source": "policy-as-code patterns",
    "license": null,
    "notes": "Checks secret/Key Vault wiring presence."
  },
  {
    "id": "gr-networking-cfn-links",
    "topic": "networking",
    "cloud": "aws",
    "iac": "cloudformation",
    "check_type": "links/dr",
    "command": "python - <<'PY'\\nimport sys,yaml,json\\nwith open('template.yaml') as f:\\n    t=yaml.safe_load(f)\\nresources=t.get('Resources',{})\\nfound=any(r.get('Type','').lower().find(x)>=0 for r in resources.values() for x in ['peering','route','vpn','transit','gateway'])\\nsys.exit(0 if found else 1)\\nPY\\n[ $? -eq 0 ] || (echo \\\"guardrail unmet: required links missing\\\" && exit 1)",
    "fail_message": "guardrail unmet: required links missing",
    "source": "opa-contrib patterns",
    "license": "Apache-2.0",
    "notes": "Checks for networking link resources."
  },
  {
    "id": "gr-security-cfn-lpv",
    "topic": "security",
    "cloud": "aws",
    "iac": "cloudformation",
    "check_type": "policy_lpv",
    "command": "python - <<'PY'\\nimport sys,yaml,json,re\\nFAIL='guardrail unmet: least-privilege policy violation'\\nPASS='guardrail met'\\nwith open('template.yaml') as f:\\n    t=yaml.safe_load(f)\\njs=json.dumps(t or {})\\ncount=0\\nif re.search(r'\\\\\\\\b(Owner|Contributor)\\\\\\\\b', js, re.I):\\n    count+=1\\nif re.search(r'Microsoft\\\\\\\\.(Authorization/.*/write|KeyVault/.*/delete)', js, re.I):\\n    count+=1\\nif count>0:\\n    print(FAIL)\\n    print(f\"issues: high_risk_or_overbroad={count}\")\\n    sys.exit(1)\\nprint(PASS)\\nPY\\n",
    "fail_message": "guardrail unmet: least-privilege policy violation",
    "source": "checkov rule patterns",
    "license": "Apache-2.0",
    "notes": "LPV heuristic for CloudFormation: flags Owner/Contributor or high-risk verbs; aggregated counts only."
  },
  {
    "id": "gr-cost-cfn-tags",
    "topic": "cost",
    "cloud": "aws",
    "iac": "cloudformation",
    "check_type": "tags",
    "command": "python - <<'PY'\\nimport sys,yaml\\nwith open('template.yaml') as f:\\n    t=yaml.safe_load(f)\\nresources=t.get('Resources',{})\\nfound=False\\nfor r in resources.values():\\n    tags=r.get('Properties',{}).get('Tags',[])\\n    keys=[(tag.get('Key') or '').lower() for tag in tags]\\n    if 'owner' in keys and 'costcenter' in keys:\\n        found=True\\n        break\\nsys.exit(0 if found else 1)\\nPY\\n[ $? -eq 0 ] || (echo \\\"guardrail unmet: standard tags missing\\\" && exit 1)",
    "fail_message": "guardrail unmet: standard tags missing",
    "source": "internal baseline",
    "license": null,
    "notes": "Chargeback tags check."
  },
  {
    "id": "gr-dr-cfn-secondary",
    "topic": "dr",
    "cloud": "aws",
    "iac": "cloudformation",
    "check_type": "dr_secondary",
    "command": "python - <<'PY'\\nimport sys,yaml\\nwith open('template.yaml') as f:\\n    t=yaml.safe_load(f)\\nresources=t.get('Resources',{})\\nfound=any('secondary' in (r.get('Properties',{}).get('Name','') or '').lower() or 'dr' in (r.get('Properties',{}).get('Name','') or '').lower() for r in resources.values())\\nsys.exit(0 if found else 1)\\nPY\\n[ $? -eq 0 ] || (echo \\\"guardrail unmet: DR secondary missing\\\" && exit 1)",
    "fail_message": "guardrail unmet: DR secondary missing",
    "source": "topic fingerprint baseline",
    "license": null,
    "notes": "Secondary region presence heuristic."
  },
  {
    "id": "gr-observability-cfn-telemetry",
    "topic": "observability",
    "cloud": "aws",
    "iac": "cloudformation",
    "check_type": "telemetry",
    "command": "python - <<'PY'\\nimport sys,yaml\\nwith open('template.yaml') as f:\\n    t=yaml.safe_load(f)\\nresources=t.get('Resources',{})\\nfound=any(r.get('Type','').lower().find(x)>=0 for r in resources.values() for x in ['log','logging','metric','alarm'])\\nsys.exit(0 if found else 1)\\nPY\\n[ $? -eq 0 ] || (echo \\\"guardrail unmet: telemetry missing\\\" && exit 1)",
    "fail_message": "guardrail unmet: telemetry missing",
    "source": "checkov patterns",
    "license": "Apache-2.0",
    "notes": "Requires logging/metrics resources."
  },
  {
    "id": "gr-ci-cd-cfn-secret-scope",
    "topic": "ci_cd",
    "cloud": "aws",
    "iac": "cloudformation",
    "check_type": "secret_scope",
    "command": "python - <<'PY'\\nimport sys,yaml\\nwith open('template.yaml') as f:\\n    t=yaml.safe_load(f)\\nresources=t.get('Resources',{})\\nfound=any('secret' in str(r.get('Properties',{})).lower() for r in resources.values())\\nsys.exit(0 if found else 1)\\nPY\\n[ $? -eq 0 ] || (echo \\\"guardrail unmet: secret scope missing\\\" && exit 1)",
    "fail_message": "guardrail unmet: secret scope missing",
    "source": "policy-as-code patterns",
    "license": null,
    "notes": "Checks for scoped secrets."
  },
  {
    "id": "gr-networking-pulumi-links",
    "topic": "networking",
    "cloud": null,
    "iac": "pulumi",
    "check_type": "links/dr",
    "command": "pulumi stack output --json | jq -e 'tostring|test(\"peering|route|vpn|gateway\")' >/dev/null || (echo \"guardrail unmet: required links missing\" && exit 1)",
    "fail_message": "guardrail unmet: required links missing",
    "source": "opa-contrib patterns",
    "license": "Apache-2.0",
    "notes": "Heuristic on exported resources; neutral."
  },
  {
    "id": "gr-security-pulumi-wildcard",
    "topic": "security",
    "cloud": null,
    "iac": "pulumi",
    "check_type": "policy_lpv",
    "signals": [
      "high_risk_verbs",
      "overbroad_builtins"
    ],
    "command": "pulumi stack output --json | python - <<'PY'\nimport json, re, sys\nFAIL='guardrail unmet: least-privilege policy violation'\nPASS='guardrail met'\ntry:\n    data=json.load(sys.stdin)\nexcept Exception:\n    print(FAIL)\n    print('issues: high_risk_verbs=1, overbroad_builtins=0')\n    sys.exit(1)\njs=json.dumps(data)\nhigh_risk = 0\noverbroad = 0\nif re.search(r'Microsoft\\\\.(Authorization/.*/write|KeyVault/.*/delete)', js, re.I):\n    high_risk += 1\nif re.search(r'\\b(Owner|Contributor)\\b', js, re.I):\n    overbroad += 1\nif high_risk or overbroad:\n    print(FAIL)\n    print('issues: high_risk_verbs={}, overbroad_builtins={}'.format(high_risk, overbroad))\n    sys.exit(1)\nprint(PASS)\nPY\n",
    "fail_message": "guardrail unmet: least-privilege policy violation",
    "source": "checkov rule patterns",
    "license": "Apache-2.0",
    "notes": "LPV heuristic for Pulumi stack outputs: flags high-risk verbs or over-broad built-ins with aggregated counts."
  },
  {
    "id": "gr-cost-pulumi-tags",
    "topic": "cost",
    "cloud": null,
    "iac": "pulumi",
    "check_type": "tags",
    "command": "pulumi stack output --json | jq -e 'tostring|test(\"owner\") and tostring|test(\"cost\")' >/dev/null || (echo \"guardrail unmet: standard tags missing\" && exit 1)",
    "fail_message": "guardrail unmet: standard tags missing",
    "source": "internal baseline",
    "license": null,
    "notes": "Checks for chargeback tags in outputs."
  },
  {
    "id": "gr-dr-pulumi-secondary",
    "topic": "dr",
    "cloud": null,
    "iac": "pulumi",
    "check_type": "dr_secondary",
    "command": "pulumi stack output --json | jq -e 'tostring|test(\"secondary|dr\")' >/dev/null || (echo \"guardrail unmet: DR secondary missing\" && exit 1)",
    "fail_message": "guardrail unmet: DR secondary missing",
    "source": "topic fingerprint baseline",
    "license": null,
    "notes": "Secondary region heuristic."
  },
  {
    "id": "gr-observability-pulumi-telemetry",
    "topic": "observability",
    "cloud": null,
    "iac": "pulumi",
    "check_type": "telemetry",
    "command": "pulumi stack output --json | jq -e 'tostring|test(\"log|logging|metric|monitor\")' >/dev/null || (echo \"guardrail unmet: telemetry missing\" && exit 1)",
    "fail_message": "guardrail unmet: telemetry missing",
    "source": "checkov patterns",
    "license": "Apache-2.0",
    "notes": "Requires logging/metrics signals."
  },
  {
    "id": "gr-ci-cd-pulumi-secret-scope",
    "topic": "ci_cd",
    "cloud": null,
    "iac": "pulumi",
    "check_type": "secret_scope",
    "command": "pulumi stack output --json | jq -e 'tostring|test(\"secret\")' >/dev/null || (echo \"guardrail unmet: secret scope missing\" && exit 1)",
    "fail_message": "guardrail unmet: secret scope missing",
    "source": "policy-as-code patterns",
    "license": null,
    "notes": "Checks for secrets usage in outputs."
  },
  {
    "id": "gr-containers-terraform-baseline",
    "topic": "containers",
    "cloud": null,
    "iac": "terraform",
    "check_type": "containers_baseline",
    "scope": "senior/terraform",
    "requires_tools": [
      "python3"
    ],
    "signals": [
      "cluster_missing",
      "telemetry_missing",
      "diagnostic_binding_missing",
      "reverse_link_missing",
      "route_assoc_missing",
      "tags_missing"
    ],
    "command": "python - <<'PY'\nimport os, re, sys, json\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: cluster telemetry missing'\nPASS='guardrail met'\nroot_arg=os.environ.get('IAC_ROOT','senior/terraform')\nroot=Path(root_arg)\nif not root.exists():\n    print(FAIL)\n    print('issues: iac_path_missing=1')\n    sys.exit(1)\n\ntexts=[]\ndocs=[]\nfor tf in sorted(root.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\ntext='\\n'.join(texts)\njs='\\n'.join(json.dumps(d, default=str) for d in docs)\nhay=text + '\\n' + js\n\ncluster_missing=0\ntelemetry_missing=0\ndiagnostic_binding_missing=0\nreverse_link_missing=0\nroute_assoc_missing=0\ntags_missing=0\n\n# cluster present\nif re.search(r'resource\\s+\"(azurerm_kubernetes_cluster|aws_eks_cluster|google_container_cluster)\"', hay, re.I) is None:\n    cluster_missing=1\n\n# telemetry primitives present\nif re.search(r'azurerm_monitor_diagnostic_setting|azurerm_log_analytics_workspace|aws_cloudwatch_|google_logging_|google_monitoring_', hay, re.I) is None:\n    telemetry_missing=1\n\n# diagnostic binding to cluster (per diagnostic setting block, not cross-file)\ndiag_blocks = list(re.finditer(r'resource\\s+\"azurerm_monitor_diagnostic_setting\"\\s+\"[^\\\"]+\"\\s*\\{(.*?)\\}', hay, re.S|re.I))\nif diag_blocks:\n    bound = False\n    for m in diag_blocks:\n        block = m.group(1)\n        if re.search(r'target_resource_id\\s*=.*kubernetes_cluster', block, re.I):\n            bound = True\n            break\n    if not bound:\n        diagnostic_binding_missing=1\nelse:\n    diagnostic_binding_missing=1\n\n# reverse links/peerings/routes between primary/secondary (require both directions)\nprimary_to_secondary = re.search(r'remote_virtual_network_id\\s*=.*(secondary|sec)', hay, re.S|re.I)\nsecondary_to_primary = re.search(r'provider\\s*=\\s*azurerm\\.secondary[\\s\\S]*?remote_virtual_network_id', hay, re.I) or re.search(r'remote_virtual_network_id\\s*=.*(primary|pri)', hay, re.S|re.I)\nif not (primary_to_secondary and secondary_to_primary):\n    reverse_link_missing=1\n\n# route table association for spokes\nif re.search(r'azurerm_subnet_route_table_association', hay, re.I) is None:\n    route_assoc_missing=1\n\n# tags (Owner and CostCenter)\nif not (re.search(r'\\bOwner\\b', hay, re.I) and re.search(r'CostCenter', hay, re.I)):\n    tags_missing=1\n\nif any([cluster_missing, telemetry_missing, diagnostic_binding_missing, reverse_link_missing, route_assoc_missing, tags_missing]):\n    print(FAIL)\n    print('issues: cluster_missing={}, telemetry_missing={}, diagnostic_binding_missing={}, reverse_link_missing={}, route_assoc_missing={}, tags_missing={}'.format(cluster_missing, telemetry_missing, diagnostic_binding_missing, reverse_link_missing, route_assoc_missing, tags_missing))\n    sys.exit(1)\n\nprint(PASS)\nPY\n",
    "fail_message": "guardrail unmet: cluster telemetry missing",
    "source": "topic_fingerprints baseline",
    "license": null,
    "notes": "Offline-safe heuristic: requires a cluster resource plus telemetry/diagnostic signals bound to the cluster; scoped to senior/terraform with aggregated counts. Requires python-hcl2."
  },
  {
    "id": "gr-containers-terraform-rbac-lpv",
    "topic": "containers",
    "cloud": null,
    "iac": "terraform",
    "check_type": "containers_rbac_lpv",
    "scope": "senior/terraform",
    "requires_tools": [
      "python3"
    ],
    "signals": [
      "overbroad_builtins",
      "high_risk_verbs",
      "broad_scopes"
    ],
    "command": "python - <<'PY'\nimport os, re, sys, json\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: least-privilege policy violation'\nPASS='guardrail met'\nroot_arg=os.environ.get('IAC_ROOT','senior/terraform')\nroot=Path(root_arg)\nif not root.exists():\n    print(FAIL)\n    print('issues: iac_path_missing=1')\n    sys.exit(1)\n\ntexts=[]\ndocs=[]\nfor tf in sorted(root.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\ntext='\\n'.join(texts)\njs='\\n'.join(json.dumps(d, default=str) for d in docs)\nhay=text + '\\n' + js\n\noverbroad_builtins=0\nhigh_risk_verbs=0\nbroad_scopes=0\n\n# look for subscription-scoped Contributor/Owner role assignments and high-risk verbs in role definitions\nif re.search(r'role_definition_name\\s*=\\s*\"(Owner|Contributor)\"', hay, re.I):\n    overbroad_builtins += 1\nif re.search(r'Microsoft\\.(Authorization/.*/write|KeyVault/.*/delete)', hay, re.I):\n    high_risk_verbs += 1\nif re.search(r'scope\\s*=\\s*\"/subscriptions/', hay, re.I):\n    broad_scopes += 1\n\nif any([overbroad_builtins, high_risk_verbs, broad_scopes]):\n    print(FAIL)\n    print(\n        f'issues: overbroad_builtins={overbroad_builtins}, '\n        f'high_risk_verbs={high_risk_verbs}, '\n        f'broad_scopes={broad_scopes}'\n    )\n    sys.exit(1)\n\nprint(PASS)\nPY\n",
    "fail_message": "guardrail unmet: least-privilege policy violation",
    "source": "LPV heuristic applied to container footprint",
    "license": "Apache-2.0",
    "notes": "Offline-safe LPV for container stacks: flags over-broad built-ins (Owner/Contributor), high-risk verbs, and subscription-scoped assignments; aggregated counts only, scoped to senior/terraform. Requires python-hcl2."
  },
  {
    "id": "gr-containers-bicep-rbac-lpv",
    "topic": "containers",
    "cloud": "azure",
    "iac": "bicep",
    "check_type": "containers_rbac_lpv",
    "scope": "senior/bicep",
    "requires_tools": [
      "python3",
      "az",
      "jq"
    ],
    "signals": [
      "high_risk_verbs",
      "overbroad_builtins"
    ],
    "command": "az bicep build --file main.bicep --stdout | python - <<'PY'\nimport sys, json, re\nFAIL='guardrail unmet: least-privilege policy violation'\nPASS='guardrail met'\ntry:\n    data=json.load(sys.stdin)\nexcept Exception:\n    print(FAIL)\n    print('issues: high_risk_verbs=1, overbroad_builtins=0')\n    sys.exit(1)\njs=json.dumps(data)\nhigh_risk=0\noverbroad=0\nif re.search(r'Microsoft\\\\.(Authorization/.*/write|KeyVault/.*/delete)', js, re.I):\n    high_risk+=1\nif re.search(r'\\b(Owner|Contributor)\\b', js, re.I):\n    overbroad+=1\nif high_risk or overbroad:\n    print(FAIL)\n    print('issues: high_risk_verbs={}, overbroad_builtins={}'.format(high_risk, overbroad))\n    sys.exit(1)\nprint(PASS)\nPY\n",
    "fail_message": "guardrail unmet: least-privilege policy violation",
    "source": "LPV heuristic applied to container footprint",
    "license": "Apache-2.0",
    "notes": "LPV for container stacks in Bicep output: flags high-risk verbs and over-broad built-ins; aggregated counts only."
  },
  {
    "id": "gr-containers-cfn-rbac-lpv",
    "topic": "containers",
    "cloud": "aws",
    "iac": "cloudformation",
    "check_type": "containers_rbac_lpv",
    "scope": "senior/cloudformation",
    "requires_tools": [
      "python3",
      "pyyaml"
    ],
    "signals": [
      "overbroad_builtins",
      "high_risk_verbs"
    ],
    "command": "python - <<'PY'\nimport sys, yaml, json, re\nFAIL='guardrail unmet: least-privilege policy violation'\nPASS='guardrail met'\ntry:\n    t=yaml.safe_load(open('template.yaml'))\nexcept Exception:\n    print(FAIL)\n    print('issues: high_risk_verbs=1, overbroad_builtins=0')\n    sys.exit(1)\njs=json.dumps(t or {})\noverbroad=0\nhigh_risk=0\nif re.search(r'AdministratorAccess|iam:\\\\*|\\\\*:\\\\*', js, re.I):\n    overbroad+=1\nif re.search(r'kms:DeleteKey|secretsmanager:DeleteSecret|iam:PutRolePolicy', js, re.I):\n    high_risk+=1\nif high_risk or overbroad:\n    print(FAIL)\n    print('issues: high_risk_verbs={}, overbroad_builtins={}'.format(high_risk, overbroad))\n    sys.exit(1)\nprint(PASS)\nPY\n",
    "fail_message": "guardrail unmet: least-privilege policy violation",
    "source": "LPV heuristic applied to container footprint",
    "license": "Apache-2.0",
    "notes": "LPV for container stacks in CloudFormation: flags admin/wildcard IAM and high-risk verbs; aggregated counts only."
  },
  {
    "id": "gr-containers-pulumi-rbac-lpv",
    "topic": "containers",
    "cloud": null,
    "iac": "pulumi",
    "check_type": "containers_rbac_lpv",
    "scope": "senior/pulumi",
    "requires_tools": [
      "python3",
      "jq",
      "pulumi"
    ],
    "signals": [
      "overbroad_builtins",
      "high_risk_verbs"
    ],
    "command": "pulumi stack output --json | python - <<'PY'\nimport sys, json, re\nFAIL='guardrail unmet: least-privilege policy violation'\nPASS='guardrail met'\ntry:\n    data=json.load(sys.stdin)\nexcept Exception:\n    print(FAIL)\n    print('issues: high_risk_verbs=1, overbroad_builtins=0')\n    sys.exit(1)\njs=json.dumps(data)\noverbroad=0\nhigh_risk=0\nif re.search(r'AdministratorAccess|iam:\\\\*|\\\\*:\\\\*|\\b(Owner|Contributor)\\b', js, re.I):\n    overbroad+=1\nif re.search(r'kms:DeleteKey|secretsmanager:DeleteSecret|Microsoft\\\\.(Authorization/.*/write|KeyVault/.*/delete)', js, re.I):\n    high_risk+=1\nif high_risk or overbroad:\n    print(FAIL)\n    print('issues: high_risk_verbs={}, overbroad_builtins={}'.format(high_risk, overbroad))\n    sys.exit(1)\nprint(PASS)\nPY\n",
    "fail_message": "guardrail unmet: least-privilege policy violation",
    "source": "LPV heuristic applied to container footprint",
    "license": "Apache-2.0",
    "notes": "LPV for container stacks in Pulumi outputs: flags admin/wildcard or high-risk verbs; aggregated counts only."
  },
  {
    "id": "gr-containers-bicep-baseline",
    "topic": "containers",
    "cloud": "azure",
    "iac": "bicep",
    "check_type": "containers_baseline",
    "command": "az bicep build --file main.bicep --stdout | jq -e '([.resources[]?|select((.type|ascii_downcase)==\"microsoft.containerservice/managedclusters\")] | length>0) and ( ([.resources[]?|select((.type|ascii_downcase)==\"microsoft.containerservice/managedclusters\")|(.properties.addonProfiles.omsagent.enabled?==true)]|any) or ([.resources[]?|select((.type|ascii_downcase)==\"microsoft.insights/diagnosticsettings\")]|length>0) )' >/dev/null || (echo \"guardrail unmet: cluster telemetry missing\" && exit 1)",
    "fail_message": "guardrail unmet: cluster telemetry missing",
    "source": "topic_fingerprints baseline",
    "license": null,
    "notes": "Requires AKS resource and either OMS agent enabled or diagnostic settings present."
  },
  {
    "id": "gr-containers-cfn-baseline",
    "topic": "containers",
    "cloud": "aws",
    "iac": "cloudformation",
    "check_type": "containers_baseline",
    "command": "python - <<'PY'\\nimport sys,yaml,json\\nt=yaml.safe_load(open('template.yaml'))\\nresources=t.get('Resources',{})\\nclusters=[r for r in resources.values() if (r.get('Type','').lower()=='aws::eks::cluster')]\\nif not clusters:\\n  print('guardrail unmet: cluster telemetry missing'); sys.exit(1)\\n# telemetry heuristic: logging enabled in EKS cluster\\ntelemetry=any('Logging' in (c.get('Properties',{}) or {}) for c in clusters)\\nif not telemetry:\\n  print('guardrail unmet: cluster telemetry missing'); sys.exit(1)\\nprint('guardrail met')\\nPY\\n",
    "fail_message": "guardrail unmet: cluster telemetry missing",
    "source": "topic_fingerprints baseline",
    "license": null,
    "notes": "Requires EKS cluster and logging block present; neutral."
  },
  {
    "id": "gr-containers-pulumi-baseline",
    "topic": "containers",
    "cloud": null,
    "iac": "pulumi",
    "check_type": "containers_baseline",
    "command": "pulumi stack output --json | jq -e 'tostring|test(\"kubeconfig|cluster\") and tostring|test(\"log|monitor|insight|cloudwatch|analytics\")' >/dev/null || (echo \"guardrail unmet: cluster telemetry missing\" && exit 1)",
    "fail_message": "guardrail unmet: cluster telemetry missing",
    "source": "topic_fingerprints baseline",
    "license": null,
    "notes": "Heuristic on stack outputs for cluster + telemetry signals."
  },
  {
    "id": "gr-net-public-ingress-terraform",
    "topic": "security",
    "cloud": null,
    "iac": "terraform",
    "check_type": "public_ingress",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: public ingress detected'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(?s)(0\\\\.0\\\\.0\\\\.0/0|::/0)'\ncount=len(re.findall(pattern, hay, re.I))\nif count == 0:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: public ingress detected",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-net-open-egress-terraform",
    "topic": "security",
    "cloud": null,
    "iac": "terraform",
    "check_type": "open_egress",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: open egress detected'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(?s)egress[\\\\s\\\\S]*(0\\\\.0\\\\.0\\\\.0/0|::/0)'\ncount=len(re.findall(pattern, hay, re.I))\nif count == 0:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: open egress detected",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-storage-public-access-terraform",
    "topic": "security",
    "cloud": null,
    "iac": "terraform",
    "check_type": "storage_public_access",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: storage public access not blocked'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(block_public_access|public_access_prevention|public_network_access\\\\s*=\\\\s*\"Disabled\"|allow_blob_public_access\\\\s*=\\\\s*false)'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: storage public access not blocked",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-storage-encryption-terraform",
    "topic": "security",
    "cloud": null,
    "iac": "terraform",
    "check_type": "encryption_at_rest",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: encryption at rest missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(encryption|server_side_encryption|kms_key_id|customer_managed_key|disk_encryption_set_id)'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: encryption at rest missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-net-tls-only-terraform",
    "topic": "security",
    "cloud": null,
    "iac": "terraform",
    "check_type": "tls_only",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: tls enforcement missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(https_only|ssl_policy|min_tls_version|tls_version)'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: tls enforcement missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-net-sg-association-terraform",
    "topic": "networking",
    "cloud": null,
    "iac": "terraform",
    "check_type": "security_group_assoc",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: security group association missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(network_security_group_id|nsg_id|vpc_security_group_ids|security_group_ids)'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: security group association missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-net-flow-logs-terraform",
    "topic": "observability",
    "cloud": null,
    "iac": "terraform",
    "check_type": "flow_logs",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: flow logs missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(flow_log|flowlog|vpc_flow_log|network_watcher_flow_log)'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: flow logs missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-observability-diagnostic-settings-terraform",
    "topic": "observability",
    "cloud": null,
    "iac": "terraform",
    "check_type": "diagnostic_settings",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: diagnostic settings missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(diagnostic_setting|monitor_diagnostic_setting|log_analytics_workspace)'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: diagnostic settings missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-iam-conditions-terraform",
    "topic": "security",
    "cloud": null,
    "iac": "terraform",
    "check_type": "iam_conditions",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: iam conditions missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='condition'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: iam conditions missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-iam-wildcard-dataplane-terraform",
    "topic": "security",
    "cloud": null,
    "iac": "terraform",
    "check_type": "iam_wildcard_dataplane",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: wildcard data-plane actions detected'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='data_actions\\\\s*=\\\\s*\\\\[[^\\\\]]*\\\\*[^\\\\]]*\\\\]'\ncount=len(re.findall(pattern, hay, re.I))\nif count == 0:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: wildcard data-plane actions detected",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-dr-backup-retention-terraform",
    "topic": "dr",
    "cloud": null,
    "iac": "terraform",
    "check_type": "backup_retention",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: backup retention missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(backup|retention)'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: backup retention missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-terraform-provider-pin-terraform",
    "topic": "ci_cd",
    "cloud": null,
    "iac": "terraform",
    "check_type": "provider_pin",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: provider version not pinned'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(?s)required_providers[\\\\s\\\\S]*version'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: provider version not pinned",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-terraform-module-pin-terraform",
    "topic": "ci_cd",
    "cloud": null,
    "iac": "terraform",
    "check_type": "module_pin",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: module source not pinned'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(source\\\\s*=\\\\s*\"[^\"]+\\\\?ref=|version\\\\s*=\\\\s*\")'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: module source not pinned",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-cost-tags-fullset-terraform",
    "topic": "cost",
    "cloud": null,
    "iac": "terraform",
    "check_type": "tags_fullset",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: required tags missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(?s)(?=.*\\bOwner\\b)(?=.*\\bCostCenter\\b)(?=.*\\bEnv\\b)(?=.*\\bProject\\b)'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: required tags missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-cost-oversized-instance-terraform",
    "topic": "cost",
    "cloud": null,
    "iac": "terraform",
    "check_type": "oversized_instance",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: oversized instance detected'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(m5\\\\.(12|16|24)xlarge|c5\\\\.24xlarge|Standard_D(16|32|64)|n1-highmem-64)'\ncount=len(re.findall(pattern, hay, re.I))\nif count == 0:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: oversized instance detected",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-security-private-endpoints-terraform",
    "topic": "security",
    "cloud": null,
    "iac": "terraform",
    "check_type": "private_endpoints",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: private endpoints missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(private_endpoint|private_service_connection|vpc_endpoint)'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: private endpoints missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-containers-network-policy-terraform",
    "topic": "containers",
    "cloud": null,
    "iac": "terraform",
    "check_type": "network_policy",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: network policy missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(network_policy|kubernetes_network_policy)'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: network policy missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-containers-pod-security-terraform",
    "topic": "containers",
    "cloud": null,
    "iac": "terraform",
    "check_type": "pod_security",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: pod security standards missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(pod_security_policy|pod_security|security_context)'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: pod security standards missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-containers-rbac-boundary-terraform",
    "topic": "containers",
    "cloud": null,
    "iac": "terraform",
    "check_type": "rbac_boundary",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: cluster rbac boundary missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(?s)(kubernetes|aks|eks|gke).*(Owner|Contributor)'\ncount=len(re.findall(pattern, hay, re.I))\nif count == 0:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: cluster rbac boundary missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-dr-secondary-replication-terraform",
    "topic": "dr",
    "cloud": null,
    "iac": "terraform",
    "check_type": "secondary_replication",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: secondary replication missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(replication|secondary|geo_redundant|replica)'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: secondary replication missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-net-public-ip-private-subnet-terraform",
    "topic": "networking",
    "cloud": null,
    "iac": "terraform",
    "check_type": "public_ip_private_subnet",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: public ip in private tier detected'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(associate_public_ip_address\\\\s*=\\\\s*true|public_ip_address_id)'\ncount=len(re.findall(pattern, hay, re.I))\nif count == 0:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: public ip in private tier detected",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-net-private-dns-link-terraform",
    "topic": "networking",
    "cloud": null,
    "iac": "terraform",
    "check_type": "private_dns_link",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: private dns link missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(private_dns_zone_virtual_network_link|private_dns_zone)'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: private dns link missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-security-waf-terraform",
    "topic": "security",
    "cloud": null,
    "iac": "terraform",
    "check_type": "waf_missing",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: waf missing on public endpoint'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(waf|web_application_firewall|waf_enabled)'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: waf missing on public endpoint",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-security-ddos-terraform",
    "topic": "security",
    "cloud": null,
    "iac": "terraform",
    "check_type": "ddos_missing",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: ddos protection missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(ddos_protection|ddos_plan)'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: ddos protection missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-iam-scope-least-priv-terraform",
    "topic": "security",
    "cloud": null,
    "iac": "terraform",
    "check_type": "iam_scope",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: overly broad iam scope detected'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='scope\\\\s*=\\\\s*\"/subscriptions/'\ncount=len(re.findall(pattern, hay, re.I))\nif count == 0:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: overly broad iam scope detected",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-security-key-rotation-terraform",
    "topic": "security",
    "cloud": null,
    "iac": "terraform",
    "check_type": "key_rotation",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: key rotation policy missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(rotation|rotation_policy)'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: key rotation policy missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-observability-log-retention-terraform",
    "topic": "observability",
    "cloud": null,
    "iac": "terraform",
    "check_type": "log_retention",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: log retention missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='retention'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: log retention missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-observability-audit-logging-terraform",
    "topic": "observability",
    "cloud": null,
    "iac": "terraform",
    "check_type": "audit_logging",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: audit logging missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='audit'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: audit logging missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-security-resource-lock-terraform",
    "topic": "security",
    "cloud": null,
    "iac": "terraform",
    "check_type": "resource_lock",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: resource lock missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(management_lock|resource_lock|lock_level)'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: resource lock missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-cost-storage-lifecycle-terraform",
    "topic": "cost",
    "cloud": null,
    "iac": "terraform",
    "check_type": "storage_lifecycle",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: storage lifecycle policy missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(lifecycle_rule|lifecycle)'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: storage lifecycle policy missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-containers-private-registry-terraform",
    "topic": "containers",
    "cloud": null,
    "iac": "terraform",
    "check_type": "private_registry",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: private registry missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(container_registry|acr|ecr|artifact_registry)'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: private registry missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-security-cmk-required-terraform",
    "topic": "security",
    "cloud": null,
    "iac": "terraform",
    "check_type": "cmk_required",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: customer-managed key missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(kms_key_id|customer_managed_key|cmk|disk_encryption_set_id)'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: customer-managed key missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-net-subnet-segmentation-terraform",
    "topic": "networking",
    "cloud": null,
    "iac": "terraform",
    "check_type": "subnet_segmentation",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: subnet tier segregation missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(?s)(?=.*subnet.*app)(?=.*subnet.*db)'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: subnet tier segregation missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-net-nat-egress-terraform",
    "topic": "networking",
    "cloud": null,
    "iac": "terraform",
    "check_type": "nat_egress",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: nat egress missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(nat_gateway|cloud_nat|natgw)'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: nat egress missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-security-approved-images-terraform",
    "topic": "security",
    "cloud": null,
    "iac": "terraform",
    "check_type": "approved_images",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: approved image reference missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(image_id|source_image_id)[^\\\\n]*(golden|hardened|approved)'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: approved image reference missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-dr-backup-vault-terraform",
    "topic": "dr",
    "cloud": null,
    "iac": "terraform",
    "check_type": "backup_vault",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: backup vault missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(backup_vault|recovery_vault|vault)'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: backup vault missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-dr-multi-az-terraform",
    "topic": "dr",
    "cloud": null,
    "iac": "terraform",
    "check_type": "multi_az",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: multi-az coverage missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(availability_zone|zones|multi_az)'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: multi-az coverage missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-net-health-probe-terraform",
    "topic": "networking",
    "cloud": null,
    "iac": "terraform",
    "check_type": "health_probe",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: health probe missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(health_check|health_probe|probe)'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: health probe missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-cost-autoscaling-bounds-terraform",
    "topic": "cost",
    "cloud": null,
    "iac": "terraform",
    "check_type": "autoscaling_bounds",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: autoscaling bounds missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(?s)(?=.*min_size)(?=.*max_size)'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: autoscaling bounds missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-security-inline-secrets-terraform",
    "topic": "security",
    "cloud": null,
    "iac": "terraform",
    "check_type": "inline_secrets",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: inline secrets detected'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(password\\\\s*=\\\\s*\"[^\"]+\"|secret\\\\s*=\\\\s*\"[^\"]+\")'\ncount=len(re.findall(pattern, hay, re.I))\nif count == 0:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: inline secrets detected",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-net-tier-sg-separation-terraform",
    "topic": "networking",
    "cloud": null,
    "iac": "terraform",
    "check_type": "tier_sg_separation",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: tier security group separation missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(?s)(?=.*network_security_group.*app)(?=.*network_security_group.*db)'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: tier security group separation missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-security-service-endpoints-terraform",
    "topic": "security",
    "cloud": null,
    "iac": "terraform",
    "check_type": "service_endpoints",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: service endpoints missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='service_endpoints'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: service endpoints missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-security-keyvault-firewall-terraform",
    "topic": "security",
    "cloud": null,
    "iac": "terraform",
    "check_type": "keyvault_firewall",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: key vault firewall missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(network_acls|firewall|default_action\\\\s*=\\\\s*\"Deny\")'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: key vault firewall missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-security-disable-default-admin-terraform",
    "topic": "security",
    "cloud": null,
    "iac": "terraform",
    "check_type": "disable_admin",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: default admin not disabled'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(disable_password_authentication|admin_enabled\\\\s*=\\\\s*false|local_admin_enabled\\\\s*=\\\\s*false)'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: default admin not disabled",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-security-secret-rotation-terraform",
    "topic": "security",
    "cloud": null,
    "iac": "terraform",
    "check_type": "secret_rotation",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: secret rotation missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(secret.*rotation|rotation.*secret)'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: secret rotation missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-cost-anomaly-alerts-terraform",
    "topic": "cost",
    "cloud": null,
    "iac": "terraform",
    "check_type": "cost_anomaly_alerts",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: cost anomaly alerts missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(budget|cost_alert|billing_alert|anomaly)'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: cost anomaly alerts missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-security-endpoint-policy-terraform",
    "topic": "security",
    "cloud": null,
    "iac": "terraform",
    "check_type": "endpoint_policy",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: endpoint policy missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='endpoint[\\\\s\\\\S]*policy'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: endpoint policy missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-observability-dns-logging-terraform",
    "topic": "observability",
    "cloud": null,
    "iac": "terraform",
    "check_type": "dns_logging",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: dns logging missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(dns_query_logging|dns_logging|query_log|log_config)'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: dns logging missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-net-egress-allowlist-terraform",
    "topic": "networking",
    "cloud": null,
    "iac": "terraform",
    "check_type": "egress_allowlist",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: egress allowlist missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='egress[\\\\s\\\\S]*prefix_list'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: egress allowlist missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  },
  {
    "id": "gr-dr-backup-test-terraform",
    "topic": "dr",
    "cloud": null,
    "iac": "terraform",
    "check_type": "backup_test",
    "requires_tools": [
      "python3"
    ],
    "command": "python - <<'PY'\nimport json, re, sys\nfrom pathlib import Path\nimport hcl2\nFAIL='guardrail unmet: backup test evidence missing'\nPASS='guardrail met'\nROOT=Path('.')\ntexts=[]\ndocs=[]\nfor tf in sorted(ROOT.rglob('*.tf')):\n    try:\n        text=tf.read_text(encoding='utf-8', errors='ignore')\n    except Exception:\n        continue\n    texts.append(text)\n    try:\n        docs.append(hcl2.loads(text))\n    except Exception:\n        continue\nhay='\\n'.join(texts) + '\\n' + '\\n'.join(json.dumps(d, default=str) for d in docs)\npattern='(restore|backup_test|backup_validation)'\ncount=len(re.findall(pattern, hay, re.I))\nif count >= 1:\n    print(PASS)\n    sys.exit(0)\nprint(FAIL)\nprint(\"issues: pattern_count={}\".format(count))\nsys.exit(1)\nPY\n",
    "fail_message": "guardrail unmet: backup test evidence missing",
    "source": "offline python-hcl2 heuristic",
    "license": null,
    "notes": "Offline-safe heuristic. Requires python-hcl2. Count-based check."
  }
]
